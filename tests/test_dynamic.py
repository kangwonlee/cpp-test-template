# begin test/test_dynamic.py
import difflib
import pathlib
import random
import subprocess

from typing import Tuple


import pytest



@pytest.fixture
def int_pool() -> Tuple[int]:
    return tuple(i for i in range(-20, 21) if i != 0)


@pytest.fixture
def float_pool() -> Tuple[float]:
    """
    Choose a pool of floats from -2.00 to 2.00, excluding 0.00.
    The floats are represented as strings with a maximum of two decimal places.
    This ensures that the output format matches the expected precision.
    The pool is generated by multiplying integers from -2000 to 2000 (excluding 0)
    by 0.01, which gives us a range of floats from -20.00 to 20.00 with two decimal places.
    """
    pool = [i*0.01 for i in range(-2000, 2000+1) if i != 0]
    pool_str = [(x, f"{x}") for x in pool]

    result = [x for x, xs in pool_str if (len(xs.split('.')[-1]) <= 2)]

    return tuple(result)


@pytest.fixture
def a(int_pool: Tuple[int]) -> int:
    return random.choice(int_pool)


@pytest.fixture
def b(int_pool: Tuple[int]) -> int:
    return random.choice(int_pool)


@pytest.fixture
def c(float_pool: Tuple[float]) -> float:
    return random.choice(float_pool)


@pytest.fixture
def d(float_pool: Tuple[float]) -> float:
    return random.choice(float_pool)


def get_expected_output(a: int, b: int, c: float, d: float) -> str:
    # Expected output
    return (
        f"##########\n"
        f"a = {a}\n"
        f"b = {b}\n"
        f"a + b = {a + b}\n"
        f"a - b = {a - b}\n"
        f"a * b = {a * b}\n"
        f"##########\n"
        f"c = {c:.2f}\n"
        f"d = {d:.2f}\n"
        f"c + d = {(c + d):.2f}\n"
        f"c - d = {(c - d):.2f}\n"
        f"c * d = {(c * d):.2f}\n"
    )


def test_arithmetic_output(
    proj_folder: pathlib.Path,
    a: int, b: int, c: float, d: float
):
    """Test that the program handles random inputs and outputs arithmetic results correctly."""

    # Prepare input string
    input_str = f"{a} {b}\n{c:.2f} {d:.2f}\n"

    # Run the program
    result = subprocess.run(
        [str(proj_folder / "tests" / "test_exec")],
        input=input_str,
        capture_output=True,
        text=True,
    )

    # Check return code
    assert result.returncode == 0, f"Program failed with return code {result.returncode}\nstderr: {result.stderr}"

    expected_output = get_expected_output(a, b, c, d)

    # Compare outputs using difflib
    if result.stdout != expected_output:
        diff = difflib.unified_diff(
            expected_output.splitlines(keepends=True),
            result.stdout.splitlines(keepends=True),
            fromfile="expected",
            tofile="actual",
        )
        diff_str = "".join(diff)
        assert False, f"Output mismatch:\n{diff_str}"


if "__main__" == __name__:
    pytest.main([__file__])

# end test/test_dynamic.py
