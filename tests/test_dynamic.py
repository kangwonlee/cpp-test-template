# begin test/test_dynamic.py
import ctypes
import math
import pathlib
import random


from typing import Tuple


import pytest


@pytest.fixture
def int_pool() -> Tuple[int]:
    return tuple(i for i in range(-20, 21) if i != 0)


@pytest.fixture
def float_pool() -> Tuple[float]:
    """
    Choose a pool of floats from -2.00 to 2.00, excluding 0.00.
    The floats are represented as strings with a maximum of two decimal places.
    This ensures that the output format matches the expected precision.
    The pool is generated by multiplying integers from -2000 to 2000 (excluding 0)
    by 0.01, which gives us a range of floats from -20.00 to 20.00 with two decimal places.
    """
    pool = [i*0.01 for i in range(-2000, 2000+1) if i != 0]
    pool_str = [(x, f"{x}") for x in pool]

    result = [x for x, xs in pool_str if (len(xs.split('.')[-1]) <= 2)]

    return tuple(result)


@pytest.fixture
def a(int_pool:Tuple[int]) -> int:
    return random.choice(int_pool)


@pytest.fixture
def b(int_pool:Tuple[int]) -> int:
    return random.choice(int_pool)


@pytest.fixture
def c(float_pool:Tuple[float]) -> float:
    return random.choice(float_pool)


@pytest.fixture
def d(float_pool:Tuple[float]) -> float:
    return random.choice(float_pool)


@pytest.fixture
def expected_a_b(a:int, b:int) -> Tuple[int]:
    return (a+b, a-b, a*b)


@pytest.fixture
def expected_c_d(c:float, d:float) -> Tuple[float]:
    return (c+d, c-d, c*d)


@pytest.fixture(scope="module")
def lib_path(my_test_folder:pathlib.Path) -> pathlib.Path:
    # Get the path to the shared library
    result = my_test_folder / "libexercise.so"

    if not result.exists():
        pytest.fail(
            f"Shared library not found at {result}. "
            "Ensure it is built correctly."
        )

    return result


# Load the shared library built by CMake/make
@pytest.fixture(scope="module")
def lib(lib_path:pathlib.Path):
    lib = ctypes.CDLL(lib_path)
    # Set argtypes and restype for int functions
    lib.add_int.argtypes = [ctypes.c_int, ctypes.c_int]
    lib.add_int.restype = ctypes.c_int
    lib.sub_int.argtypes = [ctypes.c_int, ctypes.c_int]
    lib.sub_int.restype = ctypes.c_int
    lib.mul_int.argtypes = [ctypes.c_int, ctypes.c_int]
    lib.mul_int.restype = ctypes.c_int
    # Set argtypes and restype for float functions
    lib.add_float.argtypes = [ctypes.c_float, ctypes.c_float]
    lib.add_float.restype = ctypes.c_float
    lib.sub_float.argtypes = [ctypes.c_float, ctypes.c_float]
    lib.sub_float.restype = ctypes.c_float
    lib.mul_float.argtypes = [ctypes.c_float, ctypes.c_float]
    lib.mul_float.restype = ctypes.c_float
    return lib


def test_add_int(lib, a:int, b:int, expected_a_b:Tuple[int]):
    assert lib.add_int(10, 5) == 15
    assert lib.add_int(a, b) == expected_a_b[0]


def test_sub_int(lib, a:int, b:int, expected_a_b:Tuple[int]):
    assert lib.sub_int(10, 5) == 5
    assert lib.sub_int(a, b) == expected_a_b[1]


def test_mul_int(lib, a:int, b:int, expected_a_b:Tuple[int]):
    assert lib.mul_int(10, 5) == 50
    assert lib.mul_int(a, b) == expected_a_b[2]


@pytest.fixture
def rel_tol() -> float:
    return 1e-6


def test_add_float(lib, c:float, d:float, expected_c_d:Tuple[float], rel_tol:float):
    assert math.isclose(lib.add_float(1.5, 2.5), 4.0, rel_tol=rel_tol)
    assert math.isclose(lib.add_float(c, d), expected_c_d[0], rel_tol=rel_tol)


def test_sub_float(lib, c:float, d:float, expected_c_d:Tuple[float], rel_tol:float):
    assert math.isclose(lib.sub_float(1.5, 2.5), -1.0, rel_tol=rel_tol)
    assert math.isclose(lib.sub_float(c, d), expected_c_d[1], rel_tol=rel_tol)


def test_mul_float(lib, c:float, d:float, expected_c_d:Tuple[float], rel_tol:float):
    assert math.isclose(lib.mul_float(1.5, 2.5), 3.75, rel_tol=rel_tol)
    assert math.isclose(lib.mul_float(c, d), expected_c_d[2], rel_tol=rel_tol)


if __name__ == "__main__":
    pytest.main([__file__])

# end test/test_dynamic.py
